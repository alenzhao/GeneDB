package org.genedb.db.loading.auxiliary;

import org.genedb.db.loading.ParsingException;
import org.genedb.util.TwoKeyMap;

import org.apache.log4j.Logger;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;


/**
 * Represents a single row of an Pfam output file.
 *
 * @author art
 * @author rh11
 * @author te3
 *
 */
class PfamRow {
    private static final Logger logger = Logger.getLogger(PfamFile.class);

    int lineNumber;
    String key, nativeProg, db, nativeAcc, nativeDesc, score, evalue, version;
    PfamAcc acc = PfamAcc.NULL;
    int fmin, fmax;

    // The columns we're interested in:
    private static final int COL_KEY         = 0;
    private static final int COL_NATIVE_ACC  = 5;
    private static final int COL_NATIVE_DESC = 6;
    private static final int COL_FMIN        = 1;
    private static final int COL_FMAX        = 2;
    private static final int COL_SCORE       = 11;
    private static final int COL_EVALUE      = 12;
    private static final int COL_SIG         = 13;

    /**
     * Convert a row of an Pfam output file to an PfamRow object.
     *
     * @param lineNumber the line number of this line in the input file.
     *          Used to produce more helpful diagnostics if there's a
     *          problem decoding the line.
     * @param rowFields a line of the input file
     */
    PfamRow(int lineNumber, String row) {
        this(lineNumber, row.split("\\s+"));
    }

    /**
     * Convert a row of an Pfam output file to an PfamRow object.
     *
     * @param lineNumber the line number of this line in the input file.
     *          Used to produce more helpful diagnostics if there's a
     *          problem decoding the line.
     * @param rowFields an array containing the fields in the file.
     *  In the actual file, fields are separated by multiple space characters.
     */
    PfamRow(int lineNumber, String[] rowFields) {

	if (rowFields.length == 15 && rowFields[COL_NATIVE_ACC].substring(0, 2).equals("PF") && rowFields[COL_SIG].equals("1")) { 

	    this.lineNumber = lineNumber;
	    this.key        = rowFields[COL_KEY];

	    this.nativeAcc  = rowFields[COL_NATIVE_ACC];

	    this.nativeDesc = rowFields[COL_NATIVE_DESC];
	    this.nativeProg = "pfam_scan";
	    this.db         = "Pfam";
	    this.fmin       = Integer.parseInt(rowFields[COL_FMIN]) - 1; // -1 because we're converting to interbase
	    this.fmax       = Integer.parseInt(rowFields[COL_FMAX]);
	    this.score      = rowFields[COL_SCORE];
	    this.evalue     = rowFields[COL_EVALUE];
	    
	    if (rowFields.length > COL_NATIVE_DESC && !rowFields[COL_NATIVE_ACC].equals("NULL")) {
		this.acc = new PfamAcc(rowFields[COL_NATIVE_ACC], rowFields[COL_NATIVE_DESC]);
	    }
	}
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder();
        sb.append(String.format("%s/%s: %s (%s), location %d-%d",
            key, acc.getId(), nativeDesc, nativeProg, fmin, fmax));
        return sb.toString();
    }
}

/**
 * Represents an Pfam accession identifier with description,
 * as found in the last two columns of an PfamScan raw output file.
 * 
 * @author rh11
 */
class PfamAcc {
    private String id, description;
    public static final PfamAcc NULL = new PfamAcc(null, null);

    public PfamAcc(String id, String description) {
        this.id = id;
        this.description = description;
    }

    public String getId() {
        return id;
    }

    public String getDescription() {
        return description;
    }

    /*
     * hashCode() and equals() are auto-generated by Eclipse.
     * We need them because we want to use PfamAcc objects
     * as keys in a map.
     */
    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result + ((description == null) ? 0 : description.hashCode());
        result = prime * result + ((id == null) ? 0 : id.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        final PfamAcc other = (PfamAcc) obj;
        if (description == null) {
            if (other.description != null)
                return false;
        } else if (!description.equals(other.description))
            return false;
        if (id == null) {
            if (other.id != null)
                return false;
        } else if (!id.equals(other.id))
            return false;
        return true;
    }
}

/**
 * Represents an Pfam output file as a collection of {@link PfamRow}s
 * keyed by gene name (or mangled polypeptide name) and Pfam accession number.
 *
 * @author rh11
 */
public class PfamFile {
    private static final Logger logger = Logger.getLogger(PfamFile.class);

    private TwoKeyMap<String,PfamAcc,Set<PfamRow>> rowsByKeyAndAcc
        = new TwoKeyMap<String, PfamAcc, Set<PfamRow>>();

    public PfamFile(InputStream inputStream) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader( inputStream ) );

        String line;
        int lineNumber = 0;
        Set<String> unrecognisedProgs = new HashSet<String>();
        while (null != (line = br.readLine())) {
            lineNumber++;
            PfamRow row = new PfamRow(lineNumber, line);

            if (row.db == null) {
                if (!unrecognisedProgs.contains(row.nativeProg)) {
                    logger.warn(String.format("Unrecognised program '%s', first encountered on line %d", row.nativeProg, lineNumber));
                    unrecognisedProgs.add(row.nativeProg);
                }
                continue;
            }

	    if (!rowsByKeyAndAcc.containsKey(row.key, row.acc))
		rowsByKeyAndAcc.put(row.key, row.acc, new HashSet<PfamRow>());
	    rowsByKeyAndAcc.get(row.key, row.acc).add(row);
	    
        }
    }
    public Set<String> keys() {
        return rowsByKeyAndAcc.firstKeySet();
    }
    public Set<PfamAcc> accsForKey(String key) {
        if (!rowsByKeyAndAcc.containsFirstKey(key))
            throw new IllegalArgumentException(
                String.format("Key '%s' not found", key));
        return rowsByKeyAndAcc.getMap(key).keySet();
    }
    public Set<PfamRow> rows(String key, PfamAcc acc) {
        if (!rowsByKeyAndAcc.containsKey(key, acc))
            throw new IllegalArgumentException(
                String.format("Accession number '%s' not found for key '%s'", acc, key));

        return rowsByKeyAndAcc.get(key, acc);
    }
}
