#!/software/bin/perl -wT
#########
# Author: rmp
# Maintainer: rmp
# Created: 2002-06-08
# Last Modified: 2003-05-08
# retrieve blast results and do that parsing thang
#
use strict;
use CGI qw/:cgi/;

my ($sw, $blank_gif);

BEGIN {
            unshift(@INC, "../cgi-support");
            unshift(@INC, "../cgi-support/bioperl-live");
            unshift(@INC, "../cgi-support/Sanger");

            require "GeneDB_Web.pm";
            $sw  = GeneDB_Web->new({'title'  => "Blast Server Results",
                                     'banner' => "Blast Server Results",
                                     'jsfile' => "/js/zmenu.js"
                                     });
            $blank_gif = "/images/reallyBlank.gif";
}

use Website::Blast::Parser::Generic;
use Website::Blast::Util;
use Sanger::Graphics::JSTools;

$| = 1;
$ENV{'PATH'} = "";
&main();
1;

sub main {
  my $cgi    = CGI->new();
  my $util   = Website::Blast::Util->new();
  my $format = $cgi->param('format') || "default";
  my ($id)   = $cgi->param('id') =~ /([a-zA-Z0-9]+)/;
  $id      ||= "";
  #my $sw;
  if($format eq "plain") {
    print "Content-type: text/plain\n\n";
  } else {
    #$sw = SangerWeb->new({
#			     'title'  => "Blast Server Results",
#			     'banner' => "Blast Server Results",
#			     'jsfile' => "/js/zmenu.js",
#			    });
    print $sw->header();
    print &js_menu_div();

    &retrieval_form($cgi, $util, $id);
  }

  if($id ne "") {
    &step1($cgi, $util, $id);
  }

  if($format ne "plain") {
    print "<br /><br /><br />\n";
    print $sw->footer();
  }
}

#########
# form for entering job ids
#
sub retrieval_form {
  my ($cgi, $util, $id) = @_;

  print qq(
<br /><form method="GET" action="$ENV{'SCRIPT_NAME'}">
  <table border="0" align="center" cellpadding="2" cellspacing="0" width="500">
    <tr class="violet2">
      <td><img src="$blank_gif" width="10" alt="" /></td>
      <td>
        Retrieve result for id: <input type="entry" name="id" value="$id" size="30">
        <input type="submit" value="retrieve">
      </td>
      <td><img src="$blank_gif" width="10" alt="" /></td>
    </tr>\n);

  if($id eq "") {
    print qq(
    <tr class="violet2">
      <td><img src="$blank_gif" width="10" alt="" /></td>
      <td>
        <p class="red1">
      Type your ticket identifier into the box and press
      <b>retrieve</b>.<br /> The majority of BLASTs are completed within
      two minutes.
        </p>
      </td>
      <td><img src="$blank_gif" width="10" alt="" /></td>
    </tr>\n);
  }

  my $format = $cgi->param('format') || "default";
  my @formats = (
         {'default' => "Marked up"},
         {'graphic' => "Marked up with graphics"},
         {'plain'   => "Plain Text"},
         {'ssaha'   => "SSAHA Summary"},
        );

#  print qq(  <tr class="violet2">
#    <td><img src="$blank_gif" width="10" alt="" /></td>
#    <td>    Format: <select name="format">\n);
#  for my $form (@formats) {
#    my ($key) = keys %$form;
#    my ($val) = $form->{$key};
#    my $selected = ($format eq $key)?"selected":"";
#    print qq(<option value="$key" $selected>$val</option>);
#  }
#
#  print qq(    </select></td><td><img src="$blank_gif" width="10" alt="" /></td></tr>\n);

  if($id ne "") {
    print qq(
    <tr><td colspan="3"><img src="$blank_gif" width="10" alt="" /></td></tr>
    <tr class="violet2">
      <td><img src="$blank_gif" width="10" alt="" /></td>
      <td>
    <p class="red1">
      At peak times your BLAST searches could take longer than normal.
          Please be patient.
        </p>
      </td>
      <td><img src="$blank_gif" width="10" alt="" /></td>
    </tr>\n);
    print qq(
    <tr><td colspan="3"><img src="$blank_gif" width="10" alt="" /></td></tr>
    <tr class="violet2">
      <td><img src="$blank_gif" width="10" alt="" /></td>
      <td>
    <p class="red1">
      Please note that immediately after running your BLAST searches may be
          listed as having failed. This is due to a minor systems problem. Waiting
          for a short while then retrieving the results should correct this problem.
        </p>
      </td>
      <td><img src="$blank_gif" width="10" alt="" /></td>
    </tr>\n);
    print qq(
    <tr><td colspan="3"><img src="$blank_gif" width="10" alt="" /></td></tr>
    <tr class="violet2">
      <td><img src="$blank_gif" width="10" alt="" /></td>
      <td>
    <p class="red1">
      BLAST results are kept on our servers for three days
      following query submission. Results may be retrieved any
      number of times during this period. After this time queries
      must be resubmitted if further examination is required.
        </p>
      </td>
      <td><img src="$blank_gif" width="10" alt="" /></td>
    </tr>\n);
  }

  print qq(
  </table>
</form>
<br clear="all">\n);
}

sub step1 {
  my ($cgi, $util, $id) = @_;

  my $ticket = Website::Blast::Ticket->new({'id' => $id});

  if(!defined $ticket) {
    print qq($id is not a valid identifier.);
    return;
  }

  #########
  # AntiDoS attack section (stops rapid reloading by monkeys)
  # 20 second reload limit
  #
#  my $antidos  = $ticket->basename() . ".antidos";
#  my $timethen = (stat($antidos))[9] || 0;
#  my $timenow  = time();
#  my $limit    = 5;
#  `/bin/touch $antidos`;
#  if($timenow - $timethen < $limit) {
#    #########
#    # Heh. prioritise your job down.
#    #
#    print qq(Please try again in $limit seconds.);
#    return;
#  }

  my @omnitickets = $ticket->omnitickets();

  if(scalar @omnitickets > 0) {
    #########
    # do omni hits
    #
    for my $subid (@omnitickets) {
      my $subticket = Website::Blast::Ticket->new({
                           'id' => $subid,
                          });
      my $generic   = Website::Blast::Parser::Generic->new({
                                'util'   => $util,
                                'ticket' => $subticket,
                                'skip_bioperl' => 1, # Don't build bp objs!
                               });
      if(!defined $generic) {
    my $status = $subticket->status() || $STATUS_UNKNOWN;

    if($status == $STATUS_COMPLETED) {
      print qq(Job $subid failed.<br />\n);

    } elsif($status == $STATUS_RUNNING) {
      print qq(Job $subid is running.<br />\n);

    } elsif($status == $STATUS_FAILED) {
      print qq(Job $subid failed.<br />\n);

    } else {
      print qq(Job $subid is pending execution.<br />\n);
    }
    next;
      }

      print qq(<!-- id:$subid -->\n);

      if($subticket->pfam()) {
    &step2($cgi, $util, $subid, "Website::Blast::Parser::Pfam");
      } else {
    &step2($cgi, $util, $subid, "Website::Blast::Parser::Omniblast", {'skip_bioperl'=>1});
      }
    }

  } else {
    my $generic  = Website::Blast::Parser::Generic->new({
                             'util' => $util,
                             'id'   => $id,
                             'skip_bioperl' => 1, #skip bp objs!
                            });

    if(!defined $generic) {
      my $status = $ticket->status() || $STATUS_UNKNOWN;

      if($status == $STATUS_COMPLETED) {
    print qq(Job $id failed.<br />\n);

      } elsif($status == $STATUS_RUNNING) {
    print qq(Job $id is running.<br />\n);

      } elsif($status == $STATUS_FAILED) {
    print qq(Job $id failed.<br />\n);

      } else {
    print qq(Job $id is pending execution.<br />\n);
      }
      return;
    }

    my $database = $generic->ticket->database();
    my $name     = "Generic";
    my $format   = $cgi->param('format') || "default";
    my $opts     = {
            'graphic' => ($format eq "graphic")?"on":"off",
           };

    if($format eq "ssaha") {
      $name = "SSAHA";

    } elsif($format eq "plain") {
      $name = "Plain";

  } else {
      if($database =~ /humpub\/chr/i ||
     $database =~ /humpub\/finished/ ||
     $database =~ /humpub\/public_unfinished/ ||
     $database =~ /humpub\/all/ ||
     $database =~ /humpub\/public_human/) {
    $name = "Homo_sapiens";

      } elsif($database =~ /humpub\/mouse/) {
    $name = "Mus_musculus";

      } elsif($database eq "wormpub/allcmid") {
    $name = "C_elegans";

      } elsif($database =~ /yeastpub\/NM/i) {
    $name = "N_meningitidis";

      } elsif(substr($database, 0, 11) eq "yeastpub/ML") {
    $name = "M_leprae";

      } elsif(substr($database, 0, 11) eq "yeastpub/CJ") {
    $name = "C_jejuni";

      } elsif(substr($database, 0, 6) eq "merops") {
    $name = "MEROPS";

      } elsif( $database =~ m!GeneDB_[A-Z][a-z]*_(\w*_)?(Proteins|Contigs|Genes)$! ){
    $name = "GeneDB_Link";


      } elsif( $database =~ m!EMBL! ){
    $name = "EMBL_Link";


      } elsif( $database =~ m!SWALL! ){
    $name = "SPTR_Link";


      }
    }

    my $parsername = "Website::Blast::Parser::$name";
    &step2($cgi, $util, $id, $parsername, $opts);
  }
}


sub step2 {
  my ($cgi, $util, $id, $parsername, $opts) = @_;
  $opts ||= {};

  eval "require $parsername";

  # This lets us know about compile errors in the Parse modules
  if( $@ ){
      print STDERR "ERROR: Could not 'require' $parsername\n       $@\n";
  }

  my $parser = $parsername->new({
                 'util'         => $util,
                 'id'           => $id,
                 'cgi'          => $cgi,
                 'graphic'      => $opts->{'graphic'},
                 'skip_bioperl' => $opts->{'skip_bioperl'},
                });
  $parser->parse();
}

