#!/software/bin/perl -wT
#########
# rmp 2002-03-06;  hacking fixes. offline, ticketed system
# hrh 2002-12-09;  multiple sequences
# hrh 2003-04-14;  fixing the filters
#

package blast_server;
use strict;
$|=1;

my ($web, $blank_gif, $cgi_dir);

BEGIN {
    #unshift(@INC, "/nfs/WWW/SANGER_docs/perl");
    #unshift(@INC, "/nfs/WWW/SANGER_docs/bin-offline");

    if( defined $ENV{"WEB_ROLE"}  ){
        if( $ENV{"WEB_ROLE"} eq "GeneDB" ){
            unshift(@INC, "./MODULES");
            unshift(@INC, "../../genedb-cgi-offline");        # ok in taint mode, webserver determines where this script runs
            require "GeneDB_Web.pm";
            $web = GeneDB_Web->new();
            $blank_gif = "/images/reallyBlank.gif";
        $cgi_dir = "genedb2";
        }
        else {
            print STDERR "WEB_ROLE is set but not that of 'GeneDB'\n";
        }
    }
    else {
        print STDERR "WEB_ROLE NOT DEFINED\n";

        require "SangerWeb.pm";
        $web       = SangerWeb->new();
        $blank_gif = "/gfx/blank.gif";
    $cgi_dir = "cgi-bin";
    }
}

use CGI;
use Sys::Hostname;
use Website::Blast::Util;
use Website::Blast::Ticket;

$ENV{'PATH'}        = "";

&main();
1;


sub main {
  my $cgi     = CGI->new();
  my $content = "";
  my $util    = Website::Blast::Util->new();

  my $defs = {
          'VERSION'     => "2.0",
          'HALT'        => 0,                      # Set to 1 to deactivate blast
          'limit'       => 100,                      # max number of query sequences to be submitted
          'seq_type'    => "",                     # Either DNA or protein (D/P)
          'multi'       => "yes",                  # multiple sequence submission
          'OPTIONS'     => "",                     # Blast options
#	      'PROCESSORS'  => 4,                      # No. of processors to use (max=4)
          'PROCESSORS'  => 1,                      # No. of processors to use (max=4)
         };

  if($defs->{'HALT'} == 1 || -f "/nfs/pathdb/prod/NOBLAST") {
    #########
    # blast unavailable
    #
    $content .= qq(<P><H3 align = "center">Sorry our Blast servers are temporarily out of service (please see our home page for details)</H3></P>\n);
  } else {
    #########
    # submit blast
    #
    &run($cgi, $util, \$content, $defs);
  }

  print $web->header({
                      'title'  => "BLAST Server Submission",
                  'banner' => "BLAST Server Submission",
                 });
  print $content;
  print $web->footer();
}


sub run {
  my ($cgi, $util, $content_ref, $defs) = @_;
  my %querylist = ();

  &get_web_form($cgi, $util, $content_ref, $defs);

  &check_and_clean_sequence($cgi, $util, $content_ref, $defs, \%querylist);

  my $status = &trap_errors($cgi, $util, $content_ref, $defs);

  return if(defined $status);

  &process_options($cgi, $util, $content_ref, $defs);

  &bsub($cgi, $util, $content_ref, $defs, \%querylist);
}

###############################################################
# get submitted data from the web page
#
sub get_web_form {
  my ($cgi, $util, $content_ref, $defs) = @_;

  if (defined($cgi->param('altoptions'))) {
    my $altoptions = $cgi->param('altoptions') || "";

    if( defined $altoptions && $altoptions ne "" ){
        $altoptions =~ s/[\`\'\;$\""\@\{\}\\\[\]~&\*!|]//ig;
        $cgi->param('altoptions', $altoptions);
    }
  }

  my $address = $cgi->param('address');
  $address    =~ s/^\s+//;
  $cgi->param('address', $address);

  my $sequence = $cgi->param('sequence');
  $sequence    =~ s/^\s+//;
  $cgi->param('sequence', $sequence);

  #########
  # test sequences
  #
  my $llama = qq(>LLAMA
aatttaaaataaagcaggacagtgttttcacagagaaccagtgagcca
atgagacaggtaagt
);

  my $camel = qq(>CAMEL
LNLLLAHWFSMKTLSCFILNSSLLFCSHRLLFFF
CHWLCSVLLKLPCPAFLYFRHWGSVAQWLRARAL
);

  my $ram = qq(>RAM
METTLPLPFLRRVSVPPGLNDIKEGLSREEVSCLGCVFFEVKPQ
TLEKILRFLKRHNVEFEPYFDVTALESIDDIITLLDAGARKCLSRPSSWPTSPHMVPR
CPHCHWKQRCFAFLRHRERPFALRLRSDCLRGCTVSGGGQRQENYPLLHQARSWGRSR
TVHPGRRQRNAIPILPSTGLTTKKDEAGKLAISTILSSVWKSDRPDGLLPTVVVDEHD
TALGLVYSSAARVNEALRTQTGVYQSRKRGLWYKGATSGDTQELVRISLDCDNDALKF
VVKQKGRFCHLDQSGCFGQLKGLPKLEQTLISRKQSAPEGSYTARLFSDEKLVRAKIM
EEAEELCTAQTPQEIAFEAADLFYFALTRAVAAGVTLADIERSLDAKSWKVKRRTGDA
KGKWAERRASTLRRRLAATSAPVTKEAAQETTPEKITMRRFDASKVSTEELDAALKRP
AQKSPMPSTMIIVPIIEDVRKNGDKAVLSYTHKFEKATSLTSPVLKAPFPKELMQLPE
ETIAAIDVSFENIRKFHAAQKEEKPLQVETMPGVVCSRFSRPIEAVGCYIPGGTAVLP
STALMLGVPAMVAGCNKIVFASPPRADGTITPEIVYVAHKVGAESIVLAGGAQAVAAM
VRPESITKVDKILGPGNQFVTAANMFVSNDTNAAVGIDMPAGPSEVLVIAHKDANPAF
VASDLLSRAEHGVDSQVILIAIDLDEEHLQAIEDEVHRQATELPHVQIVRGSIAHSIT
VQIKTVEEAMELSNKYAPEHLILQIKEAEKAVDLVMNAVVFIGATPSAWHYSAGVNHS
LPTYGFAKQYSGVNLASFVKHITSSNLTAEGLKNVGQAVMQLAKVGARGSRRAVSIRL
EHMSKSN\n);

  if (lc($cgi->param('sequence')) eq "llama"){
    $cgi->param('sequence', $llama);

  } elsif (lc($cgi->param('sequence')) eq "camel"){
    $cgi->param('sequence', $camel);

  } elsif (lc($cgi->param('sequence')) eq "pelican"){
    $cgi->param('sequence', $ram);
  }

  if ($cgi->param('uploadfile') =~/\w/ && $cgi->param('sequence') =~/\w/) {
    if($ENV{'HTTP_USER_AGENT'} =~ /Mac/){
      $$content_ref .= qq(
<p>
  <B>Note: Your Macintosh browser may have a bug that prevents correct functioning of the "file browse" box.</B><br />
  <B>Assuming you want to use the sequence in the box.</B>
</P>\n);

    } else {
      $$content_ref .= qq(
<p>
  <B>
    Warning: ambiguous sequence source (both file and text box contain data).<br />
    Assuming you want to use the sequence in the box.
  </B>
</P>\n);
    }

  } elsif ($cgi->param('sequence') eq "" && $cgi->param('uploadfile') ne "") {
    my $uploadfile = $cgi->param('uploadfile');
    $$content_ref .= qq(<p><B>Input sequence taken from uploaded file</B></p>\n);

    if($uploadfile){
      local $/ = undef;
      $uploadfile = <$uploadfile>;
    }
    if($uploadfile =~ /\w+/){
      $cgi->param('sequence', $uploadfile);
    }
  }
}

################################################################
# work out the sequence type
#
sub check_and_clean_sequence {
  my ($cgi, $util, $content_ref, $defs, $querylist_ref) = @_;
  my %seqlist;
  my $limit = $defs->{'limit'};

  my $p_seq = $cgi->param('sequence') || "";
  my @query_array = split (/>(\S*)[ \S]*/ , $p_seq);

  if ($#query_array == 0) {
    $query_array[1] = "UNKNOWN-QUERY";    # assign default name to a single sequence without a header line
    $query_array[2] = $p_seq;             # and set $defs->{'multi'} to "no"
    $defs->{'multi'} = "no";

  } elsif ($#query_array == 2) {          # set $defs->{'multi'} to "no" in case the fasta file contains
    $defs->{'multi'} = "no";              # only one sequence

  } elsif ($#query_array > ($limit*2)) {
    $$content_ref .=  "<p><b>only the first $limit sequences will be submitted to the blast server</b></p>";
  }

  for (my $i =1; $i < ($limit*2) && $i < $#query_array; $i++) {
    my ($query, $templength, $seq_type, $A,$C,$G,$T,$total);
    my $name = $query_array[$i];

    $i++;
    my $tempseq = $query_array[$i];
    $tempseq = uc($tempseq);
    $_ = $tempseq;
    $A = tr/A/a/;
    $C = tr/C/c/;
    $G = tr/G/g/;
    $T = tr/T/t/;
    $total = $A+$C+$G+$T;

    $tempseq =~ s/\s//g;
    $templength = length($tempseq);

    if ($templength < 1){
      $$content_ref .=  "<P><B>Sequence length is zero. Search aborted!</B><P>";
      return;
    }

    if(($total/$templength) >= 0.70) {
      #########
      # it's DNA
      #
      $tempseq  =~ s/[^ACGTUNRYKMBDHVSWNX]//ig;
      $query    = $tempseq;
      $seq_type = "D";

      if ($defs->{'seq_type'} eq "P") {
        $$content_ref .=  "<P><B>You have a mixture of DNA and protein sequences in your fasta file. Search aborted!</B></P>";
        return;

      } else {
         $defs->{'seq_type'} = "D";
      }

    } else {
      #########
      # it's protein
      #
      $tempseq  =~ s/[^ARNDCEQGHILKMFPSTWYVXZ]//ig;
      $query    = $tempseq;
      $seq_type = "P";

      if ($defs->{'seq_type'} eq "D") {
        $$content_ref .=  "<P><B>You have a mixture of DNA and protein sequences in your fasta file. Search aborted!</B><P>";
        return;
      }
      else {
         $defs->{'seq_type'} = "P";
      }
    }

    $seqlist{$name} = {
               'seq'  => $query,
               'type' => $seq_type,
              };
  }
  %{$querylist_ref} =  %seqlist;

  return
}
#########
# trap errors
#
sub trap_errors {
  my ($cgi, $util, $content_ref, $defs) = @_;

  my $warning = undef;

  my $database_type = $util->database_type($cgi->param('database')) || "";
  my $blast_type = $util->blast_type($cgi->param('blast_type')) || "";
  my $address    = $cgi->param('address')  || "";
  my $sequence   = $cgi->param('sequence') || "";
  my $seq_type   = $defs->{'seq_type'}     || "";
  my $return     = $cgi->param('return')   || "";

  $warning = qq(No Blast executable specified)            if($blast_type eq "");
  $warning = qq(No Sequence given)                        if($sequence eq "");
  $warning = qq(Invalid e-mail address specified)         if($address !~ /\@/ && $return eq "EMAIL");

  $warning = qq(You appear to have submitted a DNA sequence but you cannot perform this type of search
        ($blast_type) using a DNA sequence)        if (($blast_type eq "wutblastn" || $blast_type eq "wublastp") && $seq_type eq "D");

  $warning = qq(You appear to have submitted a protein sequence but you cannot perform this type of search
                ($blast_type) using a protein sequence)   if (($blast_type eq "wublastn" || $blast_type eq "wublastx" || $blast_type eq "wutblastx") &&	$seq_type eq "P");


  $warning = qq(You have selected a DNA database. You cannot perform a $blast_type search on  DNA database)        if (($blast_type eq "wublastx" || $blast_type eq "wublastp") && $database_type eq "D");

  $warning = qq(You have selected a protein database. You cannot perform a $blast_type search on a protein database)   if (($blast_type eq "wublastn" || $blast_type eq "wutblastx" || $blast_type eq "wutblastn") &&	$database_type eq "P");




  $$content_ref .= qq(<p><b>Error: $warning.</b></p><br /><br /><br />) if(defined $warning);

  return $warning;
}

#########
# handle the options
#
sub process_options {
  my ($cgi, $util, $content_ref, $defs) = @_;

  my $seqlength = length($cgi->param('sequence'));
  $defs->{'OPTIONS'} = "cpus=$defs->{'PROCESSORS'} -warnings";

  #########
  # Decrease the cut-off if the sequence is very small
  #
  if ($seqlength < 30 ) {
    $defs->{'OPTIONS'} .= " S=10 ";
  }

  #########
  # number of results to display
  #
  my $align = $cgi->param('align');
  $defs->{'OPTIONS'} .= " B=$align ";

  ## FILTERING #####################
  # CGI param for filtering;
  #   filtering is the checkbox
  #   filter    is the drop down list (eg: seq xnu, seq+xnu) though each option gets igno
  #
  # This code differs from the Sanger site
  #
  #
  unless (defined($cgi->param('filtering'))){    # thick box on general blast submission form
    $cgi->param('filtering', "off");
  }

  my $filter     = "";
  my $blast_type = $util->blast_type($cgi->param('blast_type'));

  unless (defined($cgi->param('filter'))){  # only available on advanced blast submission form (www.sanger)
      $cgi->param('filter', "default");
  }

  if ($cgi->param('filtering') eq "on") {

      if ($cgi->param('filter') ne "default") {
          $filter = " -filter=" . $cgi->param('filter');
      }
      else {
          if ($blast_type ne "blastn" && $blast_type ne "wublastn") {
              $filter = " -filter=seg";
          } else  {
              $filter = " -filter=dust";
          }
      }
  }

  #$$content_ref .= $filter;
  $defs->{'OPTIONS'} .= $filter;


  #########
  # set up RepeatMasker for human DB's only
  #
  my $database = $cgi->param('database')    || "";

  #########
  # change Blast matrix and other Blast options
  #
  unless ($blast_type eq "wublastn" || $blast_type eq "blastn") {
    if (defined($cgi->param('matrix'))) {
      my $matrixtype = $cgi->param('matrix');
      $defs->{'OPTIONS'} .= " -matrix=$matrixtype ";
    }
  }

  if (defined($cgi->param('expect')) && $cgi->param('expect') != 10 ) {
    my $expect = $cgi->param('expect');
    $defs->{'OPTIONS'} .= " E=$expect";
  }

  if (defined($cgi->param('descriptions')) &&  $cgi->param('descriptions') != 500 ) {
    my $descriptions = $cgi->param('descriptions');
    $defs->{'OPTIONS'} .= " V=$descriptions";

  } else {
    my $align = $cgi->param('align');
    $defs->{'OPTIONS'} .= " V=$align";  # set to same as alignments
  }

  if (defined($cgi->param('histogram')) &&  $cgi->param('histogram') eq "yes" ) {
    $defs->{'OPTIONS'} .= " H=1";
  }

  if (defined($cgi->param('sort')) && $cgi->param('sort') ne "-sort_by_pvalue") {
    my $sorttype = $cgi->param('sort');
    $defs->{'OPTIONS'} .= " $sorttype";
  }

  if (defined($cgi->param('statistics')) && $cgi->param('statistics') ne "-sump") {
    my $statistics = $cgi->param('statistics');
    $defs->{'OPTIONS'} .= " $statistics";
  }

  if ($blast_type =~ /blastx/) {
    if (defined $cgi->param('gencode') && $cgi->param('gencode') != 1){
      my $gencode = $cgi->param('gencode');
      $defs->{'OPTIONS'} .= " C=$gencode";

    } else {
      $defs->{'OPTIONS'} .= " C=1";
    }
  }

  if (defined($cgi->param('altoptions')) && $cgi->param('altoptions') =~ /\w+/) {
    my $altoptions = $cgi->param('altoptions');
    $defs->{'OPTIONS'} .= " $altoptions";
  }
}

#########
#
#
sub bsub {
  my ($cgi, $util, $content_ref, $defs, $querylist_ref) = @_;

  my $blast_type = $BLASTPATH . "/" . $util->blast_type($cgi->param('blast_type'));
  my $p_database = $cgi->param('database');

  my $database   = $util->database($p_database);

  unless( defined $database && $database ne '' ){
    $database = $p_database;
  }

  my $hostname   = &hostname();
  my $return     = $cgi->param('return') || "HTML";
  my $p_address  = $cgi->param('address');
  $p_address     =~ s/\;\|\`\"\'//g;
  my ($address)  = $p_address =~ /(\S+\@\S+)/;
  my $opts       = $defs->{'OPTIONS'};
  $opts          =~ s/\`\"\'\;\|//g;
  ($opts)        = $opts =~ /(.*)/;
  my $repmask    = $cgi->param('repeatmasker') || "no";
  ($repmask)     = $repmask =~ /(yes|no)/;

  my $dev = "";
  my $queue;

  my $uberid;
  my $uberticket;
  my @multitickets = ();
  my $status;

  if ($defs->{'multi'} eq "yes") {     # create multi ticket
    $uberid     = &get_unique_id();
    $uberticket = Website::Blast::Ticket->new({
                           'id'         => $uberid,
                           '_noload'    => 1,
                           'remotehost' => $ENV{'HTTP_X_FORWARDED_FOR'} || "",
                           'referrer'   => $ENV{'HTTP_REFERER'} || "",
                          });
    $status     = $uberticket->save();
  }

  for my $name (keys %$querylist_ref) {

    my $id       = &get_unique_id();
    my $sequence = $querylist_ref->{$name}->{'seq'};
    my $type     = $querylist_ref->{$name}->{'type'};
    my $dest     = $util->hashpath($id);
    my $fn       = $dest . ".tmp";

    eval {
      open (TEMP, ">$fn") || die "ERROR: Could not write to file $fn : $@";
      print TEMP ">$name\n$sequence\n";
      close (TEMP);
    };
    if($@) {
      my $error = $@;
      $$content_ref .= qq(<H3>Error: Could not create temporary file, try again later </H3>\n);
      print STDERR "Error: blast-server : Could not create temporary file : $error\n";
    }

    my $ticket = Website::Blast::Ticket->new({
                          'id'         => $id,
                          '_noload'    => 1,
                          'database'   => $database,
                          'query'      => $name,
                          'hostname'   => $hostname,
                          'blasttype'  => $blast_type,
                          'options'    => $opts,
                          'repeatmask' => $repmask,
                          'remotehost' => $ENV{'HTTP_X_FORWARDED_FOR'} || "",
                          'referrer'   => $ENV{'HTTP_REFERER'} || "",
                         });

    $util->blast_log({
              'id'         => $id,
              'db'         => $database,
              'type'       => $util->blast_type($cgi->param('blast_type')),
              'remotehost' => $ENV{'HTTP_X_FORWARDED_FOR'},
              'referrer'   => $ENV{'HTTP_REFERER'},
             });

    if($return eq "EMAIL") {
      $ticket->return($return);
      $ticket->address($address);
    }

    $status = $ticket->save();

    push @multitickets, $ticket;


    if($status) {
      $$content_ref .= qq(Error saving query data.<br />\n);
      warn qq(blast_server: error saving INFO: $@);
      return;
    }


    if(substr($hostname, 0, 7) eq "spider2") {
      $dev = "-dev";
    }
  }

  if ($defs->{'multi'} eq "yes") {
    $uberticket->omnitickets([map { $_->id() } @multitickets]);
    $uberticket->save();
  }



  for my $ticket (@multitickets) {

    if ($defs->{'multi'} eq "yes") {
      $queue = $util->lsf_queue($uberticket);
    }
    else {
      $queue    = $util->lsf_queue($ticket);
    }
    my $rsc      = $util->lsf_resource($ticket);
    my $runblast = $util->checkpath($RUNBLAST);

    my $id = $ticket->id;

    my $cmdline  = qq($BSUB -I -q $queue $rsc "$runblast -id=$id $dev" >/dev/null 2>&1 3>&1 &);
#   $$content_ref .= $cmdline;
    eval {
      print STDERR "$cmdline\n";
      system($cmdline);
    };
    if($@) {
      $$content_ref .= qq(Error submitting job.<br />\n);
      warn qq(blast_server: error submitting job: $@);
      return;
    }
    if ($defs->{'multi'} eq "no") {
      if($return eq "EMAIL") {
        $$content_ref .= qq(Job submitted.<br />\nYour id is $id<br />\nSending mail to $address.<br />\n<br />\n);
      } else {

    my $server_name = $ENV{'HTTP_X_FORWARDED_HOST'} || $ENV{'HTTP_X_HOST'};

        unless ($server_name) {
            $server_name = $cgi->url(-base => 1);
            $server_name =~ s|http://||;
        }

    $$content_ref .= qq(
<br /><form method="GET" action="/${cgi_dir}/blast/getblast">
  <table border="0" align="center" cellpadding="2" cellspacing="0" width="500">
    <tr class="violet2">
      <td><img src="$blank_gif" width="10" alt="" /></td>
      <td>
        Retrieve result for id: <input type="entry" name="id" value="$id" size="30">
        <input type="submit" value="retrieve">
      </td>
      <td><img src="$blank_gif" width="10" alt="" /></td>
    </tr>
    <tr><td colspan="3"><img src="$blank_gif" width="10" alt="" /></td></tr>
    <tr class="violet2">
      <td><img src="$blank_gif" width="10" alt="" /></td>
      <td>
        <p class="red1">
          Your BLAST query has been added to the queue of jobs.<br />The
          majority of BLASTs are completed within two minutes.
        </p>
      </td>
      <td><img src="$blank_gif" width="10" alt="" /></td>
    </tr>
    <tr><td colspan="3"><img src="$blank_gif" width="10" alt="" /></td></tr>
    <tr class="violet2">
      <td><img src="$blank_gif" width="10" alt="" /></td>
      <td>
        <p class="red1">
          To retrieve your results, click the <b>retrieve</b> button
          above, or use the following URL: <a href="http://$server_name/${cgi_dir}/blast/getblast?id=$id">http://$server_name/${cgi_dir}/blast/getblast?id=$id</a>
        </p>
      </td>
      <td><img src="$blank_gif" width="10" alt="" /></td>
    </tr>
  </table>
</form>\n);
      }
    }
  }

  if ($defs->{'multi'} eq "yes") {
#    $uberticket->omnitickets(\@multitickets);
#    $uberticket->save();

    if($return eq "EMAIL") {
      $$content_ref .= qq(Jobs submitted.<br />\nYour id is $uberid <br />\nSending mails to $address.<br />\n<br />\n);

    } else {
      $$content_ref .= qq(<p>Your job id is $uberid. [<a href="/${cgi_dir}/blast/getblast?id=$uberid">retrieve result</a>]</p>);
    }
  }
}

