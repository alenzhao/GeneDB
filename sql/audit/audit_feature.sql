-- Autogenerated on Tue Mar 24 12:24:23 2009 by mkaudit.pl

create table audit.feature (
    dbxref_id integer
  , feature_id integer not null
  , uniquename text not null
  , name character varying(255)
  , md5checksum character(32)
  , type_id integer not null
  , organism_id integer not null
  , seqlen integer
  , is_obsolete boolean not null
  , is_analysis boolean not null
  , timelastmodified timestamp without time zone not null
) inherits (audit.audit);

create or replace function audit.audit_feature_insert_proc()
returns trigger
as $$
BEGIN
  raise exception 'Cannot insert directly into audit.feature. Use one of the child tables.';
END;
$$ language plpgsql;
create trigger feature_insert_tr before insert on audit.feature
    for each statement execute procedure audit.audit_feature_insert_proc();


create table audit.feature_insert (
    constraint feature_insert_ck check (type = 'INSERT')
  , timeaccessioned timestamp without time zone not null
) inherits (audit.feature);
alter table audit.feature_insert alter type set default 'INSERT';

create or replace function audit.public_feature_insert_proc()
returns trigger
as $$
BEGIN
  insert into audit.feature_insert (
      feature_id, dbxref_id, organism_id, name, uniquename, seqlen, md5checksum, type_id, is_analysis, is_obsolete, timeaccessioned, timelastmodified
  ) values (
      new.feature_id, new.dbxref_id, new.organism_id, new.name, new.uniquename, new.seqlen, new.md5checksum, new.type_id, new.is_analysis, new.is_obsolete, new.timeaccessioned, new.timelastmodified
  );
  return new;
END;
$$ language plpgsql;
create trigger feature_audit_insert_tr after insert on public.feature
    for each row execute procedure audit.public_feature_insert_proc();


create table audit.feature_update (
    constraint feature_update_ck check (type = 'UPDATE')
  , old_timelastmodified timestamp without time zone not null
  , old_type_id integer not null
  , old_md5checksum character(32)
  , old_organism_id integer not null
  , old_is_obsolete boolean not null
  , old_seqlen integer
  , old_uniquename text not null
  , old_dbxref_id integer
  , old_is_analysis boolean not null
  , old_name character varying(255)
) inherits (audit.feature);
alter table audit.feature_update alter type set default 'UPDATE';

create or replace function audit.public_feature_update_proc()
returns trigger
as $$
BEGIN
  if old.feature_id <> new.feature_id or old.feature_id is null <> new.feature_id is null then
    raise exception 'If you want to change feature.feature_id (do you really?) then disable the audit trigger feature_audit_update_tr';
  end if;
  if old.timeaccessioned <> new.timeaccessioned or old.timeaccessioned is null <> new.timeaccessioned is null then
    raise exception 'If you want to change feature.timeaccessioned (do you really?) then disable the audit trigger feature_audit_update_tr';
  end if;
  insert into audit.feature_update (
      feature_id, dbxref_id, organism_id, name, uniquename, seqlen, md5checksum, type_id, is_analysis, is_obsolete, timelastmodified,
      old_dbxref_id, old_organism_id, old_name, old_uniquename, old_seqlen, old_md5checksum, old_type_id, old_is_analysis, old_is_obsolete, old_timelastmodified
   ) values (
       new.feature_id, new.dbxref_id, new.organism_id, new.name, new.uniquename, new.seqlen, new.md5checksum, new.type_id, new.is_analysis, new.is_obsolete, new.timelastmodified,
       old.dbxref_id, old.organism_id, old.name, old.uniquename, old.seqlen, old.md5checksum, old.type_id, old.is_analysis, old.is_obsolete, old.timelastmodified
   );
  return new;
END;
$$ language plpgsql;
create trigger feature_audit_update_tr after update on public.feature
    for each row execute procedure audit.public_feature_update_proc();


create table audit.feature_delete (
    constraint feature_delete_ck check (type = 'DELETE')
  , timeaccessioned timestamp without time zone not null
) inherits (audit.feature);
alter table audit.feature_delete alter type set default 'DELETE';

create or replace function audit.public_feature_delete_proc()
returns trigger
as $$
BEGIN
  insert into audit.feature_delete (
      feature_id, dbxref_id, organism_id, name, uniquename, seqlen, md5checksum, type_id, is_analysis, is_obsolete, timeaccessioned, timelastmodified
  ) values (
      old.feature_id, old.dbxref_id, old.organism_id, old.name, old.uniquename, old.seqlen, old.md5checksum, old.type_id, old.is_analysis, old.is_obsolete, old.timeaccessioned, old.timelastmodified
  );
  return old;
END;
$$ language plpgsql;
create trigger feature_audit_delete_tr after delete on public.feature
    for each row execute procedure audit.public_feature_delete_proc();
